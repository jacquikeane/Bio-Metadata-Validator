
package Bio::Metadata::PathFind;

use Moose;
use namespace::autoclean;
use Carp qw( croak carp );
use File::Slurp;

use MooseX::StrictConstructor;

use Moose::Util::TypeConstraints;
use MooseX::Types::Moose qw( ArrayRef Str );
use Bio::Metadata::Types qw( IDType );
use Bio::Metadata::Finder::Path;
use Bio::Metadata::Finder::Database;

with 'MooseX::Getopt',
     'Bio::Metadata::Role::Finder';

=head1 CONTACT

path-help@sanger.ac.uk

=cut

#-------------------------------------------------------------------------------
#- public attributes -----------------------------------------------------------
#-------------------------------------------------------------------------------

has 'id' => (
  is            => 'ro',
  isa           => Str,
  required      => 1,
  documentation => 'lane, sample or study ID, or name of file containing IDs',
);

has 'type' => (
  is            => 'ro',
  isa           => IDType,
  default       => 'lane',
  documentation => 'ID type; must be one of: study, lane, file, library, sample, species',
);

has 'file_id_type' => (
  is            => 'ro',
  isa           => enum( [ qw( lane sample ) ] ),
  default       => 'lane',
  documentation => 'type of IDs in file; must be either "lane" or "sample"',
);

# TODO need to work out how to hide attributes from Role::Finder from the
# TODO usage method that's generated by Getopt::Long::Descriptive, courtesy of
# TODO MooseX::Getopt

#-------------------------------------------------------------------------------
#- private attributes ----------------------------------------------------------
#-------------------------------------------------------------------------------

has '_find_path' => (
  is      => 'ro',
  isa     => 'Bio::Metadata::Finder::Path',
  lazy    => 1,
  writer  => '_set_find_path',
  builder => '_build_find_path',
);

sub _build_find_path {
  my $self = shift;
  return Bio::Metadata::Finder::Path->new(
    environment => $self->environment,
    config_file => $self->config_file,
  );
}

#---------------------------------------

has '_find_db' => (
  is      => 'ro',
  isa     => 'Bio::Metadata::Finder::Database',
  lazy    => 1,
  writer  => '_set_find_db',
  builder => '_build_find_db',
);

sub _build_find_db {
  my $self = shift;
  return Bio::Metadata::Finder::Database->new(
    environment => $self->environment,
    config_file => $self->config_file,
  );
}

#---------------------------------------

# somewhere to store the list of IDs that we'll search for. This could be just
# a single ID or many IDs from a file
has '_ids' => (
  traits  => ['Array'],
  is      => 'ro',
  isa     => ArrayRef[Str],
  default => sub { [] },
  handles => {
    all_ids   => 'elements',
    add_id    => 'push',
    has_ids   => 'count',
    count_ids => 'count',
  },
);

#---------------------------------------

# the actual type of the IDs we'll be searching for, since we can't rely on
# "type" to give us that
has '_id_type' => (
  is      => 'rw',
  isa     => enum( [ qw( lane sample ) ] ),
  default => 'lane',
);

#-------------------------------------------------------------------------------
#- construction ----------------------------------------------------------------
#-------------------------------------------------------------------------------

sub BUILD {
  my $self = shift;

  # if "type" is "file", we need to know what type of IDs we'll find in the
  # file
  croak qq(ERROR: if "type" is "file", you must also specify "file_id_type")
    if ( $self->type eq 'file' and not $self->file_id_type );

  # we can't use "type" to tell us reliably what kind of IDs we're working
  # with, since it can be set to "file", in which case we need to look to
  # "file_id_type" for type of IDs in the file...

  if ( $self->type eq 'file' ) {
    $self->_load_ids_from_file($self->id);
    $self->_id_type($self->file_id_type);
  }
  else {
    $self->add_id($self->id);
    $self->_id_type($self->type);
  }

}

#-------------------------------------------------------------------------------
#- public methods --------------------------------------------------------------
#-------------------------------------------------------------------------------

# sub paths {
#   my $self = shift;
#
#   my $lanes = $self->_find_lanes;
#
# }

#-------------------------------------------------------------------------------
#- private methods -------------------------------------------------------------
#-------------------------------------------------------------------------------

sub _find_lanes {
  my $self = shift;

  my @results;
  DB: foreach my $schema ( @{ $self->_find_db->available_database_schemas } ) {
    ID: foreach my $id ( $self->all_ids ) {
      my $rs = $schema->get_lanes_by_id($id, $self->_id_type);
      if ( $rs->count ) {
        push @results, $rs->all;
        last DB;
      }
    }
  }

  return \@results;
}

sub _load_ids_from_file {
  my ( $self, $filename ) = @_;

  croak "ERROR: no such file ($filename)"
    unless -f $filename;

  my @ids = grep m/^#/, read_file($filename);

  croak "ERROR: no IDs found in file ($filename)"
    unless scalar @ids;

  $self->add_id(@ids);
}

#-------------------------------------------------------------------------------

__PACKAGE__->meta->make_immutable;

1;
