
package Bio::Metadata::Manifest;

# ABSTRACT: class for working with manifest metadata

use Moose;
use namespace::autoclean;

use File::Slurp qw( write_file );
use Data::UUID;
use FileHandle;
use Carp qw( croak );
use Text::CSV_XS;
use Bio::Metadata::Types qw( MD5 UUID ChecklistType CSVType FileHandleType);
use Types::Standard qw( ArrayRef Str Int );

=head1 CONTACT

path-help@sanger.ac.uk

=cut

#-------------------------------------------------------------------------------

# public attributes

has 'checklist' => (
  is       => 'ro',
  isa      => ChecklistType,
  required => 1,
  handles  => [ 'field_names', 'fields' ],
  trigger  => sub {
    my ( $self, $checklist_object ) = @_;
    $self->_num_fields( scalar @{ $checklist_object->fields } );
  },
);

# keep track of how many fields there are in the checklist
has '_num_fields' => (
  is => 'rw',
  isa => Int,
);

has 'rows' => (
  traits  => ['Array'],
  is      => 'rw',
  isa     => ArrayRef[ArrayRef],
  default => sub { [] },
  handles => {
    add_rows   => 'push',
    add_row    => 'push',
    next_row   => 'shift',
    all_rows   => 'elements',
    get_row    => 'get',
    row_count  => 'count',
  },
);

# this is an annoying hack. We need to remove two types of "undef" artifact
# that can be generated by dumping a CSV file out of Excel:
#
# 1. Excel CSVs commonly have entirely empty rows at the bottom of the file.
# These should get stripped off later by database loading code, but we can get
# rid of them here as they fly by...
#
# 2. Excel also likes to add empty columns to the end of rows. These don't get
# stripped out anywhere else and will cause all sorts of problems when we try
# to load the data into the database.
#
# To get rid of this cruft, we have to wrap up the "add_row" and "add_rows"
# methods and mess with the input as it goes past

around 'add_rows' => \&_around_add_rows;
around 'add_row'  => \&_around_add_row;

# handle multiple rows
sub _around_add_rows {
  my $orig = shift;
  my $self = shift;

  my @input_rows  = @_;
  my @output_rows = ();

  foreach my $row ( @input_rows ) {
    no warnings 'uninitialized';
    # (otherwise the "join" makes all sorts of noise...)

    # do a simple concatenation of the fields in this row and make sure that
    # the result is not the empty string. If it is, we don't store the row and
    # simply skip to the next one. We could perhaps print a warning, but for an
    # excel-derived CSV, there could be a lot of warnings...
    next if join( '', @$row ) eq '';

    # now we know that there are actual values in the fields of this row.
    # Truncate the row to the same length as the checklist header row
    my @chopped_fields = splice @$row, $self->_num_fields;

    # let the user know if we're throwing away data in those removed columns
    my $joined_chopped_fields = join ', ', @chopped_fields;

    warn "WARNING: found data in unused fields ($joined_chopped_fields)"
      if join('', @chopped_fields) ne '';

    # and finally, store the remaining row data
    push @output_rows, $row;
  }

  # hand the edited rows array to the actual method
  return $self->$orig(@output_rows);
}

# handle a single row
sub _around_add_row {
  my $orig = shift;
  my $self = shift;

  unless ( $self->checklist ) {
    warn "WARNING: can't remove redundant trailing comma without checklist";
    return $self->$orig(@_);
  }

  my $row  = shift;

  # if the API user is trying to add empty rows individually, we'll spit the
  # dummy
  {
    no warnings 'uninitialized';

    if ( join( '', @$row ) eq '' ) {
      warn "WARNING: refusing to add an empty row to the manifest";
      return $self->$orig(@_);
    }

    my @chopped_fields = splice @$row, $self->_num_fields;

    my $joined_chopped_fields = join ', ', @chopped_fields;
    warn "WARNING: found data in unused fields ($joined_chopped_fields)"
      if join('', @chopped_fields) ne '';
  }

  return $self->$orig($row);
}

has 'row_errors' => (
  traits  => ['Array'],
  is      => 'rw',
  isa     => ArrayRef[Str],
  default => sub { [] },
  handles => {
    all_row_errors => 'elements',
    get_row_error  => 'get',
    set_row_error  => 'set',
    reset          => 'clear',
  },
);

has 'md5' => ( is => 'rw', isa => MD5 );
has 'uuid' => ( is => 'rw', isa => UUID );
has 'filename' => ( is => 'ro', isa => Str );

=attr checklist

checklist object (L<Bio::Metadata::Checklist>); B<Read-only>; specify at
instantiation

=attr rows

reference to an array containing the rows in this manifest

=attr row_errors

reference to an array containing the error messages for the invalid rows in
this manifest. The rows errors are inserted at the same position as the
corresponding invalid row, meaning that this array will have C<undef> at
positions where the original row is valid.

=attr md5

MD5 checksum value for the file from which the manifest was loaded.

=attr uuid

a UUID, as generated using L<Data::UUID>, for this manifest.

=attr filename

name of the file from which the manifest was loaded; B<Read-only>; specify
at instantiation.

B<Note> that the filename is only stored on the object. Use L<add_row> to add
rows to the manifest.

=cut

# private attributes

has '_csv' => (
  is      => 'ro',
  isa     => CSVType,
  writer  => '_set_csv', # for testing
  default => sub {
    my $csv = Text::CSV_XS->new;
    $csv->eol("\n");
    return $csv;
  },
);

has '_fh' => (
  is      => 'ro',
  isa     => FileHandleType,
  writer  => '_set_fh', # for testing
  default => sub { FileHandle->new },
);

#-------------------------------------------------------------------------------
#- construction ----------------------------------------------------------------
#-------------------------------------------------------------------------------

sub BUILD {
  my $self = shift;

  # if a UUID wasn't passed in when the object was created, generate one now
  $self->uuid( Data::UUID->new->create_str ) unless defined $self->uuid;
}

#-------------------------------------------------------------------------------
#- public methods --------------------------------------------------------------
#-------------------------------------------------------------------------------

=head1 METHODS

=head2 add_rows($row1, $row2, ...)

Add one or more rows to the manifest. C<$row> should be a reference to a list
of field values.

=head2 add_row($row)

Add a single row to the manifest.

=head2 all_rows

Returns all of the rows in the manifest as an array (as opposed to an array
ref).

=head2 get_row

Returns a reference to the specified row array.

=head2 next_row

Shifts off the next row in the list of rows. Reduces the number of rows in
the manifest by 1.

=head2 row_count

Returns the number of rows in the manifest.

=head2 all_row_errors

Returns all of the error messages for invalid rows in the manifest as an array
(as opposed to an array ref).

=head2 get_row_error($index)

Returns the error message for the specified row, or C<undef> if there is no
error for the specified row. Note that the row index is zero-based when calling
this method, i.e. the first row in the manifest is 0, not 1.

=head2 set_row_error($index, $err_msg)

Adds the given error message for the specified row. Note that the row index is
zero-based when calling this method, i.e. the first row in the manifest is 0,
not 1.

=head2 reset

Resets the manifest by deleting the error messages for invalid rows.

=head2 invalid_row_count

Returns the number of invalid rows in the manifest. Note that this is different
to the number of rows in the array containing the invalid rows, since there will
be empty slots corresponding to the valid rows in the original array.

=cut

sub invalid_row_count {
  my $self = shift;

  my $count = 0;
  foreach my $row ( @{$self->row_errors} ) {
    $count++ if defined $row;
  }
  return $count;
}

=head2 has_invalid_rows

Returns 1 if the manifest contains invalid rows, 0 otherwise

=cut

sub has_invalid_rows {
  return shift->invalid_row_count ? 1 : 0;
}

=head2 is_invalid

Alias for L<has_invalid_rows>.

=cut

sub is_invalid { shift->has_invalid_rows }

#-------------------------------------------------------------------------------

=head2 get_csv($invalid_only)

Returns the current manifest in CSV format as a string. If C<$invalid_only> is
set to true, only invalid rows will be included. The header row will always be
included as the first line of the CSV string.

=cut

sub get_csv {
  my ( $self, $invalid_only ) = @_;

  my $csv_string = '';

  my $rows = $self->_get_csv_rows($invalid_only);
  foreach my $row ( @$rows ) {
    $self->_csv->combine(@$row);
    $csv_string .= $self->_csv->string;
  }

  return $csv_string;
}

#-------------------------------------------------------------------------------

=head2 write_csv($filename, $invalid_only)

Writes the current manifest as a CSV file with the specified filename. If
C<$invalid_only> is set to true, only invalid rows will be written to the
file.

=cut

sub write_csv {
  my ( $self, $filename, $invalid_only ) = @_;

  $self->_fh->open($filename, '>')
    or croak "ERROR: couldn't open output file for write: $!";

  my $rows = $self->_get_csv_rows($invalid_only);
  $self->_csv->print( $self->_fh, $_ ) for @$rows;

  $self->_fh->close;
}

#-------------------------------------------------------------------------------
#- private methods -------------------------------------------------------------
#-------------------------------------------------------------------------------

# Returns a references to an array containing the rows in the manifest. Each
# row is given as a reference to an array containing the column values. If
# C<$invalid_only> is set to true, only invalid rows will be included. The
# header row will always be included as the first row of the array.

sub _get_csv_rows {
  my ( $self, $invalid_only ) = @_;

  # put the header line into the output CSV first
  my @rows = ();

  my @header_row = split ',', $self->checklist->get('header_row');
  push @rows, \@header_row if defined scalar @header_row;

  my $n = 0;
  foreach my $original_row ( $self->all_rows ) {

    # take a copy of the row array, so that we're not altering it if we push
    # in error messages
    my @row = @$original_row;

    # append any error messages to the row
    my $row_error = $self->get_row_error($n);
    push @row, $row_error if $row_error;

    if ( $invalid_only ) {
      push @rows, \@row if $row_error;
    }
    else {
      push @rows, \@row;
    }

    $n++;
  }

  return \@rows;
}

#-------------------------------------------------------------------------------

__PACKAGE__->meta->make_immutable;

1;
